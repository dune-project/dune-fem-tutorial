{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "626a5a3b",
   "metadata": {
    "lines_to_next_cell": 0
   },
   "source": [
    ".. index:: Solvers; Sicpy (Uzawa Saddle Point)\n",
    "\n",
    ".. index::\n",
    "   triple: Equations; Stokes; Saddle-Point;\n",
    "\n",
    "# (Quasi) Stokes equations (Scipy based Uzawa scheme)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "94f0e360",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:36:38.382613Z",
     "iopub.status.busy": "2025-11-29T12:36:38.382422Z",
     "iopub.status.idle": "2025-11-29T12:37:13.552201Z",
     "shell.execute_reply": "2025-11-29T12:37:13.551298Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0 0.05083519140846937\n",
      "1 0.004520464458157964\n",
      "2 0.0001443814586563066\n",
      "3 6.536111368146233e-06\n",
      "4 3.445323821267366e-07\n",
      "5 2.876742866210465e-08\n",
      "6 1.6235031965126378e-09\n",
      "7 2.8276576182388793e-12\n",
      "8 1.252191031009065e-13\n",
      "9 9.279809688657085e-15\n",
      "10 2.889499676340723e-15\n",
      "11 8.497927621179985e-17\n",
      "12 2.006899438791115e-19\n"
     ]
    }
   ],
   "source": [
    "from matplotlib import pyplot\n",
    "import numpy\n",
    "from scipy.sparse import bmat, linalg\n",
    "from dune.grid import cartesianDomain\n",
    "from dune.alugrid import aluCubeGrid\n",
    "from dune.fem.space import lagrange, dgonb\n",
    "from dune.fem.operator import galerkin as galerkinOperator\n",
    "from ufl import SpatialCoordinate, CellVolume, TrialFunction, TestFunction,\\\n",
    "                inner, dot, div, grad, dx, as_vector, transpose, Identity\n",
    "from dune.ufl import Constant, DirichletBC\n",
    "import dune.fem\n",
    "\n",
    "muValue = 1\n",
    "nuValue = 0.1\n",
    "order = 2\n",
    "\n",
    "grid = aluCubeGrid(constructor=cartesianDomain([0,0],[3,1],[30,10]))\n",
    "spcU = lagrange(grid, dimRange=grid.dimension, order=order, storage=\"numpy\")\n",
    "spcP = lagrange(grid, order=order-1, storage=\"numpy\")\n",
    "\n",
    "x     = SpatialCoordinate(spcU)\n",
    "mu    = Constant(muValue, \"mu\")\n",
    "nu    = Constant(nuValue, \"nu\")\n",
    "u     = TrialFunction(spcU)\n",
    "v     = TestFunction(spcU)\n",
    "p     = TrialFunction(spcP)\n",
    "q     = TestFunction(spcP)\n",
    "\n",
    "exact_u     = as_vector( [x[1] * (1.-x[1]), 0] )\n",
    "exact_p     = (-2*x[0] + 2)*mu\n",
    "f           = as_vector( [0,]*grid.dimension )\n",
    "f          += nu*exact_u\n",
    "dbc         = DirichletBC(spcU,exact_u)\n",
    "\n",
    "mainModel   = (nu*dot(u,v) + mu*inner(grad(u)+grad(u).T, grad(v)) - dot(f,v)) * dx\n",
    "gradModel   = -inner( p*Identity(grid.dimension), grad(v) ) * dx\n",
    "divModel    = -div(u)*q * dx\n",
    "massModel   = p*q * dx\n",
    "preconModel = inner(grad(p),grad(q)) * dx\n",
    "\n",
    "mainOp      = galerkinOperator( [mainModel, dbc] )\n",
    "gradOp      = galerkinOperator( [gradModel, dbc] )\n",
    "divOp       = galerkinOperator( divModel )\n",
    "massOp      = galerkinOperator( massModel )\n",
    "\n",
    "A = mainOp.linear()\n",
    "A = A.as_numpy\n",
    "def Ainv(rhs,target): target[:] = linalg.spsolve(A,rhs)\n",
    "G = gradOp.linear()\n",
    "G = G.as_numpy\n",
    "D = divOp.linear()\n",
    "D = D.as_numpy\n",
    "M = massOp.linear()\n",
    "M = M.as_numpy\n",
    "def Minv(rhs,target): target[:] = linalg.spsolve(M,rhs)\n",
    "\n",
    "if mainOp.model.nu > 0: # same as nu.value>0\n",
    "    preconOp    = galerkinOperator( (preconModel, DirichletBC(spcP,0)), spcP)\n",
    "    P = preconOp.linear().as_numpy\n",
    "    def Pinv(rhs,target): target[:] = linalg.spsolve(P,rhs)\n",
    "\n",
    "# discrete functions\n",
    "velocity = spcU.interpolate(spcU.dimRange*[0], name=\"velocity\")\n",
    "pressure = spcP.interpolate(0, name=\"pressure\")\n",
    "sol_u  = velocity.as_numpy\n",
    "sol_p  = pressure.as_numpy\n",
    "\n",
    "# aux. function\n",
    "rhsVelo  = velocity.copy()\n",
    "rhsPress = pressure.copy()\n",
    "rhs_u  = rhsVelo.as_numpy\n",
    "rhs_p  = rhsPress.as_numpy\n",
    "r      = numpy.copy(rhs_p)\n",
    "d      = numpy.copy(rhs_p)\n",
    "precon = numpy.copy(rhs_p)\n",
    "xi     = numpy.copy(rhs_u)\n",
    "\n",
    "# right hand side for Shur complement problem\n",
    "mainOp(velocity,rhsVelo)\n",
    "rhs_u *= -1\n",
    "xi[:] = G*sol_p\n",
    "rhs_u -= xi\n",
    "Ainv(rhs_u[:], sol_u[:])\n",
    "rhs_p[:] = D*sol_u\n",
    "Minv(rhs_p, r)\n",
    "if mainOp.model.nu > 0:\n",
    "    precon.fill(0)\n",
    "    Pinv(rhs_p, precon)\n",
    "    r *= mainOp.model.mu\n",
    "    r += mainOp.model.nu*precon\n",
    "d[:] = r[:]\n",
    "delta = numpy.dot(r,rhs_p)\n",
    "\n",
    "# cg type iteration\n",
    "for m in range(100):\n",
    "    xi.fill(0)\n",
    "    rhs_u[:] = G*d\n",
    "    Ainv(rhs_u[:], xi[:])\n",
    "    rhs_p[:] = D*xi\n",
    "    rho = delta / numpy.dot(d,rhs_p)\n",
    "    sol_p += rho*d\n",
    "    sol_u -= rho*xi\n",
    "    rhs_p[:] = D*sol_u\n",
    "    Minv(rhs_p[:],r[:])\n",
    "    if mainOp.model.nu > 0:\n",
    "        precon.fill(0)\n",
    "        Pinv(rhs_p,precon)\n",
    "        r *= mainOp.model.mu\n",
    "        r += mainOp.model.nu*precon\n",
    "    oldDelta = delta\n",
    "    delta = numpy.dot(r,rhs_p)\n",
    "    print(m,delta)\n",
    "    if delta < (1e-9)**2: break\n",
    "    gamma = delta/oldDelta\n",
    "    d *= gamma\n",
    "    d += r"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4a3cd9f2",
   "metadata": {
    "lines_to_next_cell": 0
   },
   "source": [
    "Now we can easily plot the velocity magnitude and pressure"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "07dd0c2d",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:37:13.554354Z",
     "iopub.status.busy": "2025-11-29T12:37:13.554029Z",
     "iopub.status.idle": "2025-11-29T12:37:13.566426Z",
     "shell.execute_reply": "2025-11-29T12:37:13.565505Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<Figure size 1000x500 with 0 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "fig = pyplot.figure(figsize=(20,10))\n",
    "velocity.plot(colorbar=\"horizontal\", figure=(fig, 121))\n",
    "pressure.plot(colorbar=\"horizontal\", figure=(fig, 122))"
   ]
  }
 ],
 "metadata": {
  "jupytext": {
   "cell_metadata_filter": "-all"
  },
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.14.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}

{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "27c8591e",
   "metadata": {},
   "source": [
    ".. index:: Grid construction; Filtered grid views\n",
    "\n",
    "# FilteredGridView examples\n",
    "\n",
    "In this example we use `filteredGridView` to filter out parts of a given\n",
    "grid view."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "c0dd331c",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:05:58.728868Z",
     "iopub.status.busy": "2025-11-29T12:05:58.728683Z",
     "iopub.status.idle": "2025-11-29T12:05:59.554111Z",
     "shell.execute_reply": "2025-11-29T12:05:59.552443Z"
    }
   },
   "outputs": [],
   "source": [
    "from ufl import SpatialCoordinate, dot\n",
    "from dune.grid import cartesianDomain\n",
    "from dune.alugrid import aluConformGrid as leafGridView\n",
    "from dune.fem.view import filteredGridView\n",
    "from dune.fem.space import lagrange\n",
    "from dune.fem.utility import inspectBoundaryIds"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3c17949b",
   "metadata": {},
   "source": [
    "Create a host grid view of the underlying grid as usual.\n",
    "We show the boundary ids and some discrete function - also note the size\n",
    "of the Lagrange space in this example:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "6536bdc5",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:05:59.556669Z",
     "iopub.status.busy": "2025-11-29T12:05:59.556347Z",
     "iopub.status.idle": "2025-11-29T12:06:00.674405Z",
     "shell.execute_reply": "2025-11-29T12:06:00.673359Z"
    },
    "lines_to_next_cell": 1
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "number of dofs: 5151 integral over original domain 1.3333333333333384\n"
     ]
    }
   ],
   "source": [
    "gridView = leafGridView( cartesianDomain([-1,0],[1,1],[50,25]) )\n",
    "space = lagrange(gridView, order=2)\n",
    "x = SpatialCoordinate(space)\n",
    "solution = space.interpolate(dot(x,x),name=\"solution\")\n",
    "solution.plot(colorbar=\"horizontal\")\n",
    "print(\"number of dofs:\", solution.size,\\\n",
    "      \"integral over original domain\",solution.integrate())\n",
    "inspectBoundaryIds(gridView).plot(colorbar=\"horizontal\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "12d21cc0",
   "metadata": {},
   "source": [
    "Now create a `filteredGridView` with a simple callable specifying which element belongs to the new domain."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "d37f9991",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:06:00.676215Z",
     "iopub.status.busy": "2025-11-29T12:06:00.675933Z",
     "iopub.status.idle": "2025-11-29T12:06:00.788971Z",
     "shell.execute_reply": "2025-11-29T12:06:00.788398Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "number of dofs:"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      " 1053 integral over filtered domain 10 0.04858624000000002\n"
     ]
    }
   ],
   "source": [
    "def filterIds(e):\n",
    "    r = e.geometry.center.two_norm\n",
    "    if r < 0.5:\n",
    "        return 10\n",
    "    elif r < 0.75:\n",
    "        return 15\n",
    "    else:\n",
    "        return 20\n",
    "filteredView10 = filteredGridView(gridView, filterIds, domainId=10,\n",
    "                                  useFilteredIndexSet=True)\n",
    "space10 = lagrange(filteredView10, order=2)\n",
    "solution10 = space10.interpolate(dot(x,x),name=\"solution\")\n",
    "solution10.plot(colorbar=\"horizontal\")\n",
    "print(\"number of dofs:\", solution10.size,\\\n",
    "      \"integral over filtered domain 10\",solution10.integrate())"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cf240dd7",
   "metadata": {},
   "source": [
    ".. note::\n",
    "   The final parameter `useFilteredIndexSet` changes the index set that\n",
    "   is used over the filtered grid view. The default is `False` so that\n",
    "   the index set is taken from the underlying grid view. If this is set\n",
    "   to `True` as here a new index set is generated that only covers the\n",
    "   the filtered part of the grid. Consequently, the size of the spaces\n",
    "   over the underlying grid view and the filtered grid view are\n",
    "   different as shown here."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7a7533c8",
   "metadata": {},
   "source": [
    "One can quite easily transfer a grid function from the filtered grid view to\n",
    "a discrete function over the containing grid or vice versa:\n",
    "Note that simply using `solution10.interpolate(solution)` will not work\n",
    "since this method requires the grid views to match:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "5555c0b4",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:06:00.791951Z",
     "iopub.status.busy": "2025-11-29T12:06:00.791545Z",
     "iopub.status.idle": "2025-11-29T12:06:00.852426Z",
     "shell.execute_reply": "2025-11-29T12:06:00.851406Z"
    }
   },
   "outputs": [],
   "source": [
    "solution.clear()\n",
    "filteredView10.interpolate(solution10,solution)\n",
    "solution.plot(colorbar=\"horizontal\")\n",
    "solution10.clear()\n",
    "filteredView10.interpolate(solution,solution10)\n",
    "solution10.plot(colorbar=\"horizontal\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0dd8dfbb",
   "metadata": {},
   "source": [
    "The boundary ids are set to original ids or to the id of the outside\n",
    "domain for internal boundaries, i.e., 15 in the current setup:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "5ef87244",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:06:00.854162Z",
     "iopub.status.busy": "2025-11-29T12:06:00.853962Z",
     "iopub.status.idle": "2025-11-29T12:06:00.945701Z",
     "shell.execute_reply": "2025-11-29T12:06:00.944704Z"
    }
   },
   "outputs": [],
   "source": [
    "inspectBoundaryIds(filteredView10).plot(colorbar=\"horizontal\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1999902b",
   "metadata": {},
   "source": [
    "Filter out a different section of the domain:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "ad44fab0",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:06:00.947533Z",
     "iopub.status.busy": "2025-11-29T12:06:00.947322Z",
     "iopub.status.idle": "2025-11-29T12:06:01.141760Z",
     "shell.execute_reply": "2025-11-29T12:06:01.140772Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "number of dofs: 5151 integral over filtered domain 15 0.2007825066666666\n"
     ]
    }
   ],
   "source": [
    "filteredView15 = filteredGridView(gridView, filterIds, domainId=15)\n",
    "space15 = lagrange(filteredView15, order=2)\n",
    "x = SpatialCoordinate(space15)\n",
    "solution15 = space15.interpolate(dot(x,x),name=\"solution\")\n",
    "solution15.plot(colorbar=\"horizontal\")\n",
    "print(\"number of dofs:\", solution15.size,\\\n",
    "      \"integral over filtered domain 15\",solution15.integrate())\n",
    "inspectBoundaryIds(filteredView15).plot(colorbar=\"horizontal\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4f86f7ec",
   "metadata": {},
   "source": [
    ".. note::\n",
    "   As mentioned already the default is for the index set over the\n",
    "   filtered grid view to be identical to that of the underlying grid view.\n",
    "   Consequently, a discrete function over this type of a filtered grid view\n",
    "   has the same number of degrees of freedom as a discrete\n",
    "   function in the same type of space over the underlying grid view.\n",
    "\n",
    "The `space15.interpolate` called above will only set the degrees of\n",
    "freedom attached to the filtered elements and will contain random\n",
    "values otherwise. For this reason it makes sense to construct a\n",
    "discrete function in this case that is guaranteed to be zero\n",
    "everywhere before performing the interpolation:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "986b7413",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:06:01.143732Z",
     "iopub.status.busy": "2025-11-29T12:06:01.143541Z",
     "iopub.status.idle": "2025-11-29T12:06:01.156805Z",
     "shell.execute_reply": "2025-11-29T12:06:01.155955Z"
    }
   },
   "outputs": [],
   "source": [
    "solution15 = space15.function(name=\"solution\")\n",
    "solution15.interpolate(dot(x,x))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1167c5e7",
   "metadata": {},
   "source": [
    "A consequence of not changing the index set is that layout of the degrees of freedom of\n",
    "discrete functions over the same spaces one over the filtered grid view\n",
    "and the other over the underlying grid view are identical.\n",
    "This makes the transfer of data very easy to achieve:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "da0e3d80",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:06:01.158565Z",
     "iopub.status.busy": "2025-11-29T12:06:01.158361Z",
     "iopub.status.idle": "2025-11-29T12:06:01.161762Z",
     "shell.execute_reply": "2025-11-29T12:06:01.160998Z"
    }
   },
   "outputs": [],
   "source": [
    "solution.clear()\n",
    "solution.assign(solution15)  # here the '0' on the domain which is not in the filter is important\n",
    "solution.plot()\n",
    "solution15.assign(solution)\n",
    "solution15.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "275bf452",
   "metadata": {},
   "source": [
    "Finally the outer part of the domain"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "470538b1",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:06:01.163567Z",
     "iopub.status.busy": "2025-11-29T12:06:01.163364Z",
     "iopub.status.idle": "2025-11-29T12:06:01.188688Z",
     "shell.execute_reply": "2025-11-29T12:06:01.187894Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "number of dofs: 2979 integral over filtered domain 20 1.0839645866666672\n"
     ]
    }
   ],
   "source": [
    "filteredView20 = filteredGridView(gridView, filterIds, domainId=20,\n",
    "                                  useFilteredIndexSet=True)\n",
    "space20 = lagrange(filteredView20, order=2)\n",
    "x = SpatialCoordinate(space20)\n",
    "solution20 = space20.interpolate(dot(x,x),name=\"solution\")\n",
    "solution20.plot(colorbar=\"horizontal\")\n",
    "print(\"number of dofs:\", solution20.size,\\\n",
    "      \"integral over filtered domain 20\",solution20.integrate())\n",
    "inspectBoundaryIds(filteredView20).plot(colorbar=\"horizontal\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "084e5707",
   "metadata": {},
   "source": [
    "Finally we solve a simple linear PDE but with some mixed boundary conditions taken\n",
    "from one of the [introduction notebooks](concepts_nb.ipynb)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "a808f277",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:06:01.191110Z",
     "iopub.status.busy": "2025-11-29T12:06:01.190916Z",
     "iopub.status.idle": "2025-11-29T12:06:01.288433Z",
     "shell.execute_reply": "2025-11-29T12:06:01.287575Z"
    }
   },
   "outputs": [],
   "source": [
    "from dune.ufl import DirichletBC\n",
    "from dune.fem.scheme import galerkin\n",
    "from ufl import ( TrialFunction, TestFunction, FacetNormal, conditional,\n",
    "                  div, grad, dx, ds )\n",
    "\n",
    "exact = 1/2*(x[0]**2+x[1]**2) - 1/3*(x[0]**3 - x[1]**3) + 1\n",
    "u     = TrialFunction(space10)\n",
    "v     = TestFunction(space10)\n",
    "f     = -div( grad(exact) )\n",
    "g_N   = grad(exact)\n",
    "n     = FacetNormal(space10)\n",
    "b     = f*v*dx + dot(g_N,n)*conditional(x[0]>=1e-8,1,0)*v*ds\n",
    "a     = dot(grad(u), grad(v)) * dx\n",
    "dbc   = DirichletBC(space10,exact,x[0]<=1e-8)\n",
    "\n",
    "scheme = galerkin([a == b, dbc], solver='cg')\n",
    "scheme.solve(target = solution10)\n",
    "solution10.plot(colorbar=\"horizontal\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a7c0b4a0",
   "metadata": {},
   "source": [
    "Letâ€™s compare with the exact solution"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "ff680c5c",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:06:01.290748Z",
     "iopub.status.busy": "2025-11-29T12:06:01.290536Z",
     "iopub.status.idle": "2025-11-29T12:06:01.346322Z",
     "shell.execute_reply": "2025-11-29T12:06:01.345521Z"
    }
   },
   "outputs": [],
   "source": [
    "from dune.fem.function import gridFunction\n",
    "gridFunction(exact,gridView=filteredView10).plot(level=3,colorbar=\"horizontal\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "52be8d27",
   "metadata": {},
   "source": [
    "We already mentioned how the boundary ids are set on internal boundaries,\n",
    "here is an example elliptic problem with different Dirichlet boundary\n",
    "conditions set on the two internal boundaries. The small part of the\n",
    "original boundary at $y=0$ will have trivial Neumann conditions:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "c61e8606",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:06:01.348285Z",
     "iopub.status.busy": "2025-11-29T12:06:01.348106Z",
     "iopub.status.idle": "2025-11-29T12:06:01.431316Z",
     "shell.execute_reply": "2025-11-29T12:06:01.430612Z"
    }
   },
   "outputs": [],
   "source": [
    "u     = TrialFunction(space15)\n",
    "v     = TestFunction(space15)\n",
    "a     = dot(grad(u), grad(v)) * dx\n",
    "dbc1  = DirichletBC(space15,1,10) # lower internal boundary (domain id there is 10)\n",
    "dbc2  = DirichletBC(space15,2,20) # upper internal boundary (domain id there is 20)\n",
    "\n",
    "scheme = galerkin([a == 0, dbc1, dbc2], solver='cg')\n",
    "scheme.solve(target = solution15)\n",
    "solution15.plot(colorbar=\"horizontal\")"
   ]
  }
 ],
 "metadata": {
  "jupytext": {
   "cell_metadata_filter": "-all"
  },
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.14.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}

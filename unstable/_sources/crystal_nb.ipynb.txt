{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "2820e1d7",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "source": [
    ".. index:: Equations; Phase Field\n",
    "\n",
    ".. index:: Adaptation; Phase Field\n",
    "\n",
    "# Adaptive phase field: crystal growth model\n",
    "Here we demonstrate crystallisation on the surface of a liquid due to cooling from [@Guyer].\n",
    "This example uses\n",
    "[dynamic grid refinement](gridviews_and_adaptivity.rst#Dynamic-Local-Grid-Refinement-and-Coarsening).\n",
    "\n",
    "Let us first set up the grid and the function space. We use the default DoF storage available in ``dune-fem`` - this can be changed for example to ``istl`` or ``petsc``."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "b6a776fd",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:22:43.668112Z",
     "iopub.status.busy": "2025-11-29T12:22:43.667898Z",
     "iopub.status.idle": "2025-11-29T12:22:45.471576Z",
     "shell.execute_reply": "2025-11-29T12:22:45.470675Z"
    },
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "import dune.fem as fem\n",
    "from dune.grid import cartesianDomain\n",
    "from dune.alugrid import aluConformGrid as leafGridView\n",
    "from dune.fem.view import adaptiveLeafGridView as adaptiveGridView\n",
    "from dune.fem.space import lagrange as solutionSpace\n",
    "from dune.fem import threading\n",
    "from dune.fem import GridMarker\n",
    "threading.use = max(4,threading.max) # use at most 4 threads\n",
    "\n",
    "order = 1\n",
    "dimDomain = 2     # we are solving this in 2D\n",
    "dimRange = 2      # we have a system with two unknowns\n",
    "domain = cartesianDomain([4, 4], [8, 8], [3, 3])\n",
    "gridView  = adaptiveGridView( leafGridView( domain ) )\n",
    "space = solutionSpace(gridView, dimRange=dimRange, order=order, storage=\"numpy\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8b96749e",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "source": [
    "We want to solve the following system of equations of variables $\\phi$ (phase field) and $T$ (temperature field)\n",
    "\n",
    "\\begin{equation}\n",
    "\\begin{aligned}\n",
    "\\tau \\frac{\\partial \\phi}{\\partial t} &= \\nabla \\cdot D \\nabla \\phi + \\phi(1-\\phi)m(\\phi, T), \\\\\n",
    "\\frac{\\partial T}{\\partial t} &= D_T \\nabla^2 T + \\frac{\\partial \\phi}{\\partial t},\n",
    "\\end{aligned}\n",
    "\\end{equation}\n",
    "\n",
    "where $D_T$ = 2.25, m is given by\n",
    "\n",
    "\\begin{equation*}\n",
    "m(\\phi, T) = \\phi - \\frac{1}{2} - \\frac{\\kappa_1}{\\pi} \\arctan(\\kappa_2 T),\n",
    "\\end{equation*}\n",
    "\n",
    "D is given by\n",
    "\n",
    "\\begin{equation*}\n",
    "D = \\alpha^2(1+c\\beta)\\left(\\begin{array}{cc}\n",
    "1 + c\\beta & -c \\frac{\\partial \\beta}{\\partial \\psi} \\\\\n",
    "c \\frac{\\partial \\beta}{\\partial \\psi} & 1+c\\beta\n",
    "\\end{array}\\right),\n",
    "\\end{equation*}\n",
    "\n",
    "and where $\\beta = \\frac{1-\\Phi^2}{1+\\Phi^2}$, $\\Phi = \\tan \\left( \\frac{N}{2} \\psi \\right)$, $\\psi = \\theta + \\arctan \\left(\\frac{\\partial \\phi/ \\partial y}{\\partial \\phi / \\partial x} \\right)$ and $\\theta$, $N$ are constants.\n",
    "\n",
    "Let us first set up the parameters for the problem."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "1bbf6387",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:22:45.474138Z",
     "iopub.status.busy": "2025-11-29T12:22:45.473819Z",
     "iopub.status.idle": "2025-11-29T12:22:45.477692Z",
     "shell.execute_reply": "2025-11-29T12:22:45.476676Z"
    },
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "alpha        = 0.015\n",
    "tau          = 3.e-4\n",
    "kappa1       = 0.9\n",
    "kappa2       = 20.\n",
    "c            = 0.02\n",
    "N            = 6."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ae63bc91",
   "metadata": {},
   "source": [
    "We define the initial data and create a function from it.\n",
    "We use this value to set up our solution."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "fa574854",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:22:45.479320Z",
     "iopub.status.busy": "2025-11-29T12:22:45.479132Z",
     "iopub.status.idle": "2025-11-29T12:22:45.547963Z",
     "shell.execute_reply": "2025-11-29T12:22:45.547171Z"
    },
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "from ufl import dot,sqrt,conditional,as_vector, SpatialCoordinate\n",
    "x = SpatialCoordinate(space)\n",
    "r = sqrt( dot( x-as_vector([6,6]), x-as_vector([6,6])) )\n",
    "initial = as_vector( [conditional(r>0.3,0,1), -0.5] )\n",
    "u_h = space.interpolate(initial, name=\"solution\")\n",
    "u_h_n = u_h.copy()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ee9fcdbe",
   "metadata": {},
   "source": [
    "As we will be discretizing in time,\n",
    "we define the unknown data as $u = (\\phi_1, \\Delta T_1)$,\n",
    "while given data (from the previous time step)\n",
    "is $u_n = (\\phi_0, \\Delta T_0)$ and test function $v = (v_0, v_1)$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "e82fe1f0",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:22:45.550194Z",
     "iopub.status.busy": "2025-11-29T12:22:45.550016Z",
     "iopub.status.idle": "2025-11-29T12:22:45.553508Z",
     "shell.execute_reply": "2025-11-29T12:22:45.552604Z"
    }
   },
   "outputs": [],
   "source": [
    "from ufl import TestFunction, TrialFunction\n",
    "from dune.ufl import Constant\n",
    "u = TrialFunction(space)\n",
    "v = TestFunction(space)\n",
    "dt = Constant(0, \"dt\")    # time step"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cedec84b",
   "metadata": {},
   "source": [
    "For the numerical scheme, we discretize the time derivatives in the usual way, and we obtain the weak form by multiplying by a test function and integrating by parts. We also express the system using vectors.\n",
    "\n",
    "This gets us the following equation.\n",
    "\n",
    "\\begin{equation}\n",
    "\\int \\left( \\alpha^2 \\frac{dt}{\\tau} (D_n\\nabla \\phi_1) \\cdot \\nabla v_0 + dt \\ D_T \\nabla T_1 \\cdot \\nabla v_1 + \\textbf{u} \\cdot \\textbf{v} - \\textbf{s} \\cdot \\textbf{v} \\right) \\ dx\n",
    "=\n",
    "\\int (\\textbf{u}_n \\cdot \\textbf{v} - \\phi_0 v_1) \\ dx\n",
    "\\end{equation}\n",
    "\n",
    "where\n",
    "\n",
    "\\begin{equation}\n",
    "\\textbf{s} = \\left( \\frac{dt}{\\tau}\\phi_1(1-\\phi_1)m(\\phi_1, T_1), \\phi_1 \\right)^T\n",
    "\\end{equation}\n",
    "\n",
    "and\n",
    "\n",
    "$D_n$ is the anisotropic diffusion using the previous solution $\\textbf{u}_n$ to compute the entries.\n",
    "\n",
    "First we put in the right hand side which only contains explicit data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "193b06d2",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:22:45.555162Z",
     "iopub.status.busy": "2025-11-29T12:22:45.554937Z",
     "iopub.status.idle": "2025-11-29T12:22:45.558410Z",
     "shell.execute_reply": "2025-11-29T12:22:45.557695Z"
    }
   },
   "outputs": [],
   "source": [
    "from ufl import inner, dx\n",
    "a_ex = (inner(u_h_n, v) - inner(u_h_n[0], v[1])) * dx"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e225d590",
   "metadata": {},
   "source": [
    "For the left hand side we have the spatial derivatives and the implicit parts."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "88b7a460",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:22:45.560357Z",
     "iopub.status.busy": "2025-11-29T12:22:45.560174Z",
     "iopub.status.idle": "2025-11-29T12:22:45.567665Z",
     "shell.execute_reply": "2025-11-29T12:22:45.566862Z"
    },
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "from ufl import pi, atan, tan, grad, inner\n",
    "try:\n",
    "    from ufl import atan2\n",
    "except ImportError: # remain compatible with version 2022 of ufl\n",
    "    from ufl import atan_2 as atan2\n",
    "\n",
    "psi        = pi/8.0 + atan2(grad(u_h_n[0])[1], (grad(u_h_n[0])[0]))\n",
    "Phi        = tan(N / 2.0 * psi)\n",
    "beta       = (1.0 - Phi*Phi) / (1.0 + Phi*Phi)\n",
    "dbeta_dPhi = -2.0 * N * Phi / (1.0 + Phi*Phi)\n",
    "fac        = 1.0 + c * beta\n",
    "diag       = fac * fac\n",
    "offdiag    = -fac * c * dbeta_dPhi\n",
    "d0         = as_vector([diag, offdiag])\n",
    "d1         = as_vector([-offdiag, diag])\n",
    "m          = u[0] - 0.5 - kappa1 / pi*atan(kappa2*u[1])\n",
    "s          = as_vector([dt / tau * u[0] * (1.0 - u[0]) * m, u[0]])\n",
    "a_im = (alpha*alpha*dt / tau * (inner(dot(d0, grad(u[0])),\n",
    "        grad(v[0])[0]) + inner(dot(d1, grad(u[0])), grad(v[0])[1]))\n",
    "        + 2.25 * dt * inner(grad(u[1]), grad(v[1]))\n",
    "        + inner(u,v) - inner(s,v)) * dx"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1fea4625",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "source": [
    "We set up the scheme with some parameters."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "07056d29",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:22:45.569499Z",
     "iopub.status.busy": "2025-11-29T12:22:45.569321Z",
     "iopub.status.idle": "2025-11-29T12:22:45.646522Z",
     "shell.execute_reply": "2025-11-29T12:22:45.645661Z"
    },
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "from dune.fem.scheme import galerkin as solutionScheme\n",
    "solverParameters = {\n",
    "        \"nonlinear.tolerance\": 1e-8,\n",
    "        \"linear.tolerance\": 1e-10,\n",
    "        \"nonlinear.verbose\": False,\n",
    "        \"linear.verbose\": False\n",
    "    }\n",
    "scheme = solutionScheme(a_im == a_ex, space, solver=\"gmres\", parameters=solverParameters)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c59da4cc",
   "metadata": {},
   "source": [
    "We set up the adaptive method. We start with a marking strategy based on the value of the gradient of the phase field variable."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "319cc349",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:22:45.648744Z",
     "iopub.status.busy": "2025-11-29T12:22:45.648565Z",
     "iopub.status.idle": "2025-11-29T12:22:45.652010Z",
     "shell.execute_reply": "2025-11-29T12:22:45.651116Z"
    },
    "lines_to_next_cell": 0
   },
   "outputs": [],
   "source": [
    "indicator = dot(grad(u_h[0]),grad(u_h[0]))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e1467820",
   "metadata": {},
   "source": [
    ".. index:: Adaptation; Marking for h-Adaptation (fast)\n",
    "\n",
    "We perform the initial refinement of the grid using the general form of the `mark' method"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "58dba4e8",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:22:45.653594Z",
     "iopub.status.busy": "2025-11-29T12:22:45.653426Z",
     "iopub.status.idle": "2025-11-29T12:22:45.888808Z",
     "shell.execute_reply": "2025-11-29T12:22:45.887999Z"
    },
    "lines_to_next_cell": 2
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "336 240 256 324 508 676 \n"
     ]
    }
   ],
   "source": [
    "maxLevel = 11\n",
    "startLevel = 5\n",
    "gridView.hierarchicalGrid.globalRefine(startLevel)\n",
    "u_h.interpolate(initial)\n",
    "\n",
    "# default marking strategy based on indicator values\n",
    "marker = GridMarker(indicator,\n",
    "                    refineTolerance  = 1.4,\n",
    "                    coarsenTolerance = 1.2,\n",
    "                    minLevel=0, maxLevel=maxLevel)\n",
    "\n",
    "for i in range(startLevel, maxLevel):\n",
    "    fem.gridAdapt(marker, u_h)\n",
    "    u_h.interpolate(initial)\n",
    "    print(gridView.size(0), end=\" \")\n",
    "print()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f1cdc637",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "source": [
    "Let us start by plotting the initial state of the material, which is just a small circle in the centre."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "24c261da",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:22:45.890721Z",
     "iopub.status.busy": "2025-11-29T12:22:45.890421Z",
     "iopub.status.idle": "2025-11-29T12:22:45.893950Z",
     "shell.execute_reply": "2025-11-29T12:22:45.893054Z"
    },
    "lines_to_next_cell": 1
   },
   "outputs": [],
   "source": [
    "from dune.fem.plotting import plotComponents\n",
    "import matplotlib.pyplot as pyplot\n",
    "from dune.fem.function import levelFunction, partitionFunction\n",
    "\n",
    "# dummy vtk\n",
    "def vtk():\n",
    "    pass"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7413a6dc",
   "metadata": {},
   "source": [
    ".. index:: Grids; Visualization time series\n",
    "\n",
    ".. index:: I/O; Plotting\n",
    "\n",
    "We can construct a vtk writer that generates a sequence of files:\n",
    "\n",
    "```\n",
    "vtk = gridView.sequencedVTK(\"crystal\", pointdata=[u_h],\n",
    "         celldata=[levelFunction(gridView), partitionFunction(gridView)])\n",
    "```\n",
    "\n",
    "This can be for example used in a time loop. Simply adding `vtk()` in the\n",
    "loop will write files `crystalXXXX.vtu` where the sequence counter `XXXX`\n",
    "is automatically increased by one each time `vtk()` is called."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "f7e6aa25",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:22:45.895649Z",
     "iopub.status.busy": "2025-11-29T12:22:45.895472Z",
     "iopub.status.idle": "2025-11-29T12:22:45.898903Z",
     "shell.execute_reply": "2025-11-29T12:22:45.898117Z"
    },
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "import matplotlib\n",
    "matplotlib.rcParams.update({'font.size': 10})\n",
    "matplotlib.rcParams['figure.figsize'] = [10, 5]\n",
    "plotComponents(u_h, cmap=pyplot.cm.jet, show=[0], contours=[0.5],contourWidth=3)\n",
    "vtk()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3f93fc59",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "source": [
    "We set ``dt`` and the initial time t=0."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "c697abd0",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:22:45.900676Z",
     "iopub.status.busy": "2025-11-29T12:22:45.900504Z",
     "iopub.status.idle": "2025-11-29T12:22:45.903433Z",
     "shell.execute_reply": "2025-11-29T12:22:45.902529Z"
    }
   },
   "outputs": [],
   "source": [
    "dt.value = 0.0005\n",
    "t = 0.0"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "443c0afa",
   "metadata": {},
   "source": [
    "Finally, we set up the time loop and solve the problem -\n",
    "each time this cell is run the simulation will progress to\n",
    "the given ``endTime`` and then the result is shown.\n",
    "The simulation can be progressed further by rerunning the cell while increasing the ``endTime``."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "ecb340d3",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-11-29T12:22:45.904955Z",
     "iopub.status.busy": "2025-11-29T12:22:45.904785Z",
     "iopub.status.idle": "2025-11-29T12:23:25.897813Z",
     "shell.execute_reply": "2025-11-29T12:23:25.896995Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "<Figure size 1500x500 with 0 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "from dune.fem.plotting import plotPointData\n",
    "u_h[0].plot(onlyContours=True,contours=[0.5], contourWidth=1, contourColor=\"black\")\n",
    "endTime = 0.1\n",
    "while t < endTime:\n",
    "    u_h_n.assign(u_h)\n",
    "    scheme.solve(target=u_h)\n",
    "    # print(t, gridView.size(0), end=\"\\r\")\n",
    "    t += dt.value\n",
    "    fem.gridAdapt(marker, u_h) # can also be a list or tuple of function to prolong/restrict\n",
    "    vtk()                      # store result in sequence of vtk file\n",
    "print()\n",
    "\n",
    "fig = pyplot.figure(figsize=(30,10))\n",
    "plotComponents(u_h, figure=fig)\n",
    "u_h[0].plot(onlyContours=True,contours=[0.5], contourWidth=1, contourColor=\"yellow\")"
   ]
  }
 ],
 "metadata": {
  "jupytext": {
   "cell_metadata_filter": "-all"
  },
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.14.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
